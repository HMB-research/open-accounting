// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: vat_rates.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/shopspring/decimal"
)

const createVATRate = `-- name: CreateVATRate :one
INSERT INTO vat_rates (country_code, rate_type, rate, name, valid_from, valid_to)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, country_code, rate_type, rate, name, valid_from, valid_to, created_at
`

type CreateVATRateParams struct {
	CountryCode string          `db:"country_code" json:"country_code"`
	RateType    string          `db:"rate_type" json:"rate_type"`
	Rate        decimal.Decimal `db:"rate" json:"rate"`
	Name        string          `db:"name" json:"name"`
	ValidFrom   pgtype.Date     `db:"valid_from" json:"valid_from"`
	ValidTo     pgtype.Date     `db:"valid_to" json:"valid_to"`
}

func (q *Queries) CreateVATRate(ctx context.Context, arg *CreateVATRateParams) (*VatRate, error) {
	row := q.db.QueryRow(ctx, createVATRate,
		arg.CountryCode,
		arg.RateType,
		arg.Rate,
		arg.Name,
		arg.ValidFrom,
		arg.ValidTo,
	)
	var i VatRate
	err := row.Scan(
		&i.ID,
		&i.CountryCode,
		&i.RateType,
		&i.Rate,
		&i.Name,
		&i.ValidFrom,
		&i.ValidTo,
		&i.CreatedAt,
	)
	return &i, err
}

const getCurrentVATRate = `-- name: GetCurrentVATRate :one
SELECT id, country_code, rate_type, rate, name, valid_from, valid_to, created_at FROM vat_rates
WHERE country_code = $1
  AND rate_type = $2
  AND valid_from <= $3
  AND (valid_to IS NULL OR valid_to >= $3)
LIMIT 1
`

type GetCurrentVATRateParams struct {
	CountryCode string      `db:"country_code" json:"country_code"`
	RateType    string      `db:"rate_type" json:"rate_type"`
	ValidFrom   pgtype.Date `db:"valid_from" json:"valid_from"`
}

func (q *Queries) GetCurrentVATRate(ctx context.Context, arg *GetCurrentVATRateParams) (*VatRate, error) {
	row := q.db.QueryRow(ctx, getCurrentVATRate, arg.CountryCode, arg.RateType, arg.ValidFrom)
	var i VatRate
	err := row.Scan(
		&i.ID,
		&i.CountryCode,
		&i.RateType,
		&i.Rate,
		&i.Name,
		&i.ValidFrom,
		&i.ValidTo,
		&i.CreatedAt,
	)
	return &i, err
}

const getVATRate = `-- name: GetVATRate :one
SELECT id, country_code, rate_type, rate, name, valid_from, valid_to, created_at FROM vat_rates
WHERE id = $1
`

func (q *Queries) GetVATRate(ctx context.Context, id uuid.UUID) (*VatRate, error) {
	row := q.db.QueryRow(ctx, getVATRate, id)
	var i VatRate
	err := row.Scan(
		&i.ID,
		&i.CountryCode,
		&i.RateType,
		&i.Rate,
		&i.Name,
		&i.ValidFrom,
		&i.ValidTo,
		&i.CreatedAt,
	)
	return &i, err
}

const listCurrentVATRates = `-- name: ListCurrentVATRates :many
SELECT id, country_code, rate_type, rate, name, valid_from, valid_to, created_at FROM vat_rates
WHERE country_code = $1
  AND valid_from <= CURRENT_DATE
  AND (valid_to IS NULL OR valid_to >= CURRENT_DATE)
ORDER BY rate_type
`

func (q *Queries) ListCurrentVATRates(ctx context.Context, countryCode string) ([]*VatRate, error) {
	rows, err := q.db.Query(ctx, listCurrentVATRates, countryCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VatRate{}
	for rows.Next() {
		var i VatRate
		if err := rows.Scan(
			&i.ID,
			&i.CountryCode,
			&i.RateType,
			&i.Rate,
			&i.Name,
			&i.ValidFrom,
			&i.ValidTo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVATRates = `-- name: ListVATRates :many
SELECT id, country_code, rate_type, rate, name, valid_from, valid_to, created_at FROM vat_rates
WHERE country_code = $1
ORDER BY rate_type, valid_from DESC
`

func (q *Queries) ListVATRates(ctx context.Context, countryCode string) ([]*VatRate, error) {
	rows, err := q.db.Query(ctx, listVATRates, countryCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*VatRate{}
	for rows.Next() {
		var i VatRate
		if err := rows.Scan(
			&i.ID,
			&i.CountryCode,
			&i.RateType,
			&i.Rate,
			&i.Name,
			&i.ValidFrom,
			&i.ValidTo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateVATRate = `-- name: UpdateVATRate :one
UPDATE vat_rates
SET rate = $2, name = $3, valid_to = $4
WHERE id = $1
RETURNING id, country_code, rate_type, rate, name, valid_from, valid_to, created_at
`

type UpdateVATRateParams struct {
	ID      uuid.UUID       `db:"id" json:"id"`
	Rate    decimal.Decimal `db:"rate" json:"rate"`
	Name    string          `db:"name" json:"name"`
	ValidTo pgtype.Date     `db:"valid_to" json:"valid_to"`
}

func (q *Queries) UpdateVATRate(ctx context.Context, arg *UpdateVATRateParams) (*VatRate, error) {
	row := q.db.QueryRow(ctx, updateVATRate,
		arg.ID,
		arg.Rate,
		arg.Name,
		arg.ValidTo,
	)
	var i VatRate
	err := row.Scan(
		&i.ID,
		&i.CountryCode,
		&i.RateType,
		&i.Rate,
		&i.Name,
		&i.ValidFrom,
		&i.ValidTo,
		&i.CreatedAt,
	)
	return &i, err
}
